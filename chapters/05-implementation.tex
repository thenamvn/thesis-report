\chapter{Implementation}
\label{chap:implementation}

This chapter details the technical implementation of the TEKUTOKO platform, translating the architectural designs and requirements from the preceding chapters into a functional system. It covers the chosen technology stack, the development of the frontend and backend components with illustrative code snippets, the integration of external services, and the deployment strategy.

\section{Development Environment and Technology Stack}
\label{sec:impl-stack}
The technology stack was selected to optimize for developer productivity, performance, scalability, and a rich, modern user experience. The key technologies are summarized in Table \ref{tab:tech-stack}.

\begin{longtable}{p{3cm} p{3cm} p{8cm}}
\caption{Technology Stack and Rationale} \label{tab:tech-stack} \\

\toprule
\textbf{Component} & \textbf{Technology / Library} & \textbf{Rationale} \\
\midrule
\endfirsthead

\toprule
\textbf{Component} & \textbf{Technology / Library} & \textbf{Rationale} \\
\midrule
\endhead

\midrule
\multicolumn{3}{r}{\textit{(continued on next page)}} \\[0.5em]
\midrule
\endfoot

\bottomrule
\endlastfoot

\textbf{Frontend} & \textbf{React 18 (with Vite)} &
A high-performance library for building dynamic, component-based SPAs.
Vite provides a significantly faster development experience than traditional bundlers. \\[0.5em]

\textbf{Styling} & \textbf{Tailwind CSS} &
A utility-first CSS framework that enables rapid, consistent, and responsive UI development directly within the JSX markup. \\[0.5em]

\textbf{Backend (Core)} & \textbf{Node.js / Express.js} &
A lightweight and efficient JavaScript runtime, ideal for building fast, scalable, and I/O-intensive REST APIs and handling real-time connections. \\[0.5em]

\textbf{Backend (Microservice)} & \textbf{Python 3 / Flask} &
A minimalist and robust framework for building the specialized DOCX parsing microservice, leveraging Python's strong data processing libraries. \\[0.5em]

\textbf{Database} & \textbf{MySQL} &
A reliable, widely-used relational database system that ensures data integrity and supports complex queries required for analytics and user data management. \\[0.5em]

\textbf{File Storage} & \textbf{Firebase Storage} &
A scalable and secure cloud storage solution that simplifies file uploads and management through its powerful SDKs and direct-to-cloud upload capabilities. \\[0.5em]

\textbf{AI Service} & \textbf{Google Gemini API} &
A state-of-the-art large language model used for the AI Question Generator, capable of understanding complex prompts and producing high-quality, structured JSON output. \\[0.5em]

\textbf{Deployment} & \textbf{Vercel, Docker} &
Vercel provides seamless CI/CD and optimized hosting for the React frontend.
Docker is used to containerize the backend services for consistent, portable deployment. \\[0.5em]

\end{longtable}


\section{Frontend Implementation (React.js)}
\label{sec:impl-frontend}
The frontend is a Single-Page Application (SPA) structured to promote modularity and reusability. The codebase is organized by features (e.g., `components/room`, `components/test`, `pages/Discovery`).

\subsection{Anti-Cheating Logic in \texttt{TestRoom} Component}
A key implementation is the proctoring system within the `TestRoom` component. It uses React's `useEffect` hook to attach and clean up browser event listeners, ensuring monitoring only occurs during an active test session. The code is shown in Listing \ref{lst:proctoring-jsx}.
\FloatBarrier
\begin{lstlisting}[language=JSX, caption={Simplified anti-cheating logic in the `TestRoom` React component.}, label={lst:proctoring-jsx}]
import React, { useEffect, useState, useCallback } from 'react';
import { logProctorEvent } from '../../api/testService'; // API call

const TestRoom = ({ roomId, userId }) => {
  const [warnings, setWarnings] = useState(0);

  // Use useCallback to memoize the logging function
  const handleSuspiciousActivity = useCallback(async (eventType, details) => {
    console.warn(`Suspicious activity: ${eventType}`, details);
    setWarnings(prev => prev + 1);
    try {
      await logProctorEvent(roomId, userId, { eventType, details });
    } catch (error) {
      console.error("Failed to log proctoring event:", error);
    }
  }, [roomId, userId]);

  useEffect(() => {
    // Handler for tab/window visibility change
    const handleVisibilityChange = () => {
      if (document.hidden) {
        handleSuspiciousActivity('tab_switch', 'User switched tab.');
      }
    };

    // Handler to prevent and log paste attempts
    const handlePaste = (e) => {
      e.preventDefault();
      handleSuspiciousActivity('paste_attempt', 'User tried to paste.');
    };
    
    document.addEventListener('visibilitychange', handleVisibilityChange);
    document.addEventListener('paste', handlePaste);

    // Cleanup function to remove listeners when component unmounts
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      document.removeEventListener('paste', handlePaste);
    };
  }, [handleSuspiciousActivity]);

  return (
    <div>
      {/* Test content goes here */}
      <div className="proctor-warning">Warnings: {warnings}</div>
    </div>
  );
};
\end{lstlisting}

\FloatBarrier
\subsection{GPS-Based Room Discovery}
The "Nearby" feature uses the browser's Geolocation API. Upon user consent, it retrieves the device's coordinates and sends them to the backend to find geographically close rooms.
\FloatBarrier
\begin{lstlisting}[language=JSX, caption={Logic for finding nearby rooms using the Geolocation API.}]
import React, { useState } from 'react';
import { findNearbyRooms } from '../../api/discoveryService';

const Discovery = () => {
  const [nearbyRooms, setNearbyRooms] = useState([]);
  const [isLoading, setIsLoading] = useState(false);

  const handleFindNearby = () => {
    if (!navigator.geolocation) {
      alert("Geolocation is not supported by your browser.");
      return;
    }
    
    setIsLoading(true);
    navigator.geolocation.getCurrentPosition(async (position) => {
      const { latitude, longitude } = position.coords;
      const rooms = await findNearbyRooms(latitude, longitude);
      setNearbyRooms(rooms);
      setIsLoading(false);
    }, () => {
      alert("Unable to retrieve your location.");
      setIsLoading(false);
    });
  };
  // ... JSX to render button and rooms
};
\end{lstlisting}
\FloatBarrier

\section{Backend Implementation (Node.js)}
\label{sec:impl-backend}
The Node.js backend uses Express.js to manage routing, middleware, and business logic.

\subsection{AI Question Generation with Prompt Engineering}
The `/api/rooms/generate-ai` endpoint demonstrates prompt engineering by constructing a detailed, structured prompt for the Google Gemini API. This ensures the model returns a predictable JSON object, simplifying parsing, as shown in Listing \ref{lst:prompt-engineering}.
\FloatBarrier
\begin{lstlisting}[language=JavaScript, caption={Backend service for generating questions via Gemini API with prompt engineering.}, label={lst:prompt-engineering}]
const { GoogleGenerativeAI } = require("@google/generative-ai");
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

async function generateQuestions(topic, numQuestions) {
  const model = genAI.getGenerativeModel({ model: "gemini-pro" });

  const prompt = `
    You are an expert educational content creator.
    Generate a JSON object containing an array of ${numQuestions} questions 
    about "${topic}".
    Each question object must have: "question_text", "options" (an array
    of 4 strings), "correct_answer" (the correct string), and "explanation".
    Do not include any text or markdown formatting outside of the main JSON object.
  `;

  const result = await model.generateContent(prompt);
  const response = await result.response;
  const text = response.text();
  
  // Clean and parse the response to ensure it's valid JSON
  const jsonResponse = JSON.parse(text.replace(/```json/g, '').replace(/```/g, ''));
  return jsonResponse;
}

module.exports = { generateQuestions };
\end{lstlisting}
\FloatBarrier

\subsection{Secure Voucher Verification}
The `/api/vouchers/verify` endpoint handles QR code verification. It receives the unique data from the scanned code, queries the database to check its validity and redemption status, and performs an atomic update to prevent double-spending.

\FloatBarrier
\begin{lstlisting}[language=JavaScript, caption={Express.js route for secure voucher verification.}]
const express = require('express');
const router = express.Router();
const db = require('../config/db');
const authMiddleware = require('../middleware/auth');

router.post('/verify', authMiddleware, async (req, res) => {
  const { qrCodeData } = req.body;

  try {
    const [vouchers] = await db.promise().query(
      'SELECT * FROM vouchers WHERE qr_code_data = ?', [qrCodeData]
    );

    if (vouchers.length === 0) {
      return res.status(404).json({ error: 'Voucher not found.' });
    }
    const voucher = vouchers[0];
    if (voucher.is_redeemed) {
      return res.status(400).json({ error: 'Voucher already redeemed.' });
    }

    // Mark as redeemed
    await db.promise().query(
      'UPDATE vouchers SET is_redeemed = TRUE, redeemed_at = NOW() WHERE voucher_id = ?',
      [voucher.voucher_id]
    );
    res.status(200).json({ success: true, message: 'Voucher redeemed.' });
  } catch (error) {
    res.status(500).json({ error: 'Server error.' });
  }
});
\end{lstlisting}
\FloatBarrier

\section{Python Microservice Implementation}
\label{sec:impl-python}
The DOCX parsing microservice is a simple Flask application containerized with Docker. It exposes a single `/parse` endpoint that processes an uploaded file in-memory.

\FloatBarrier
\begin{lstlisting}[language=Python, caption={Core logic of the Flask-based DOCX parsing microservice.}]
from flask import Flask, request, jsonify
from docx import Document
import io

app = Flask(__name__)

@app.route('/parse', methods=['POST'])
def parse_docx():
    if 'file' not in request.files:
        return jsonify({"error": "No file part in the request"}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No file selected"}), 400

    try:
        # Read the file in-memory
        doc = Document(io.BytesIO(file.read()))
        questions = []
        # Logic to parse paragraphs to extract questions and answers
        for para in doc.paragraphs:
            if para.text.strip().startswith("Q:"):
                questions.append({"text": para.text.strip()})
        
        return jsonify({"questions": questions}), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5001)
\end{lstlisting}
\FloatBarrier

\section{Deployment and CI/CD Pipeline}
\label{sec:impl-deployment}
The deployment strategy is designed for automation, scalability, and separation of concerns.
\begin{enumerate}
    \item \textbf{Frontend (React):} The project is linked to a GitHub repository. A push to the `main` branch automatically triggers a new build and deployment on \textbf{Vercel}. Vercel's global CDN ensures fast load times for users worldwide. Environment variables for the backend API URL are managed through the Vercel dashboard.
    
    \item \textbf{Backend Services (Node.js \& Python):} Both the Node.js backend and the Python microservice are containerized using \textbf{Docker}. A `Dockerfile` in each service's directory defines its environment and dependencies. These container images are pushed to a container registry (like Docker Hub or Google Container Registry) and can be deployed to any container orchestration platform like Google Cloud Run or AWS Fargate. This allows them to be scaled independently based on traffic and ensures a consistent runtime environment from development to production.
\end{enumerate}